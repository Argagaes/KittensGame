
// These control the button statuses
var auto = new Object(); // Is a toggle holder. Use like ``auto.craft = true; if (auto.craft) { ...
var programBuild = false;

// These will allow quick selection of the buildings which consume energy
var bldBioLab = gamePage.bld.getBuildingExt('biolab').meta;
var bldOilWell = gamePage.bld.getBuildingExt('oilWell').meta;
var bldFactory = gamePage.bld.getBuildingExt('factory').meta;
var bldCalciner = gamePage.bld.getBuildingExt('calciner').meta;
var bldAccelerator = gamePage.bld.getBuildingExt('accelerator').meta;

// These are the assorted variables
var proVar = gamePage.resPool.energyProd;
var conVar = gamePage.resPool.energyCons;
var deadScript = "Script is dead";
var paperChoice = 'none';
var autoChoice = "farmer";
var cycleChoice = 0;
var secResRatio = 25;
var steamOn = 0;


var buildings = [/*
    // list is autogenerated, looks like:
    ["Catnip Field", "field", false],
    ...
*/];
for (var i=0; i<gamePage.bld.buildingsData.length; i++) {
    var data = gamePage.bld.buildingsData[i];
    if (! data.stages) var label = data.label;
    else var label = data.stages.map(function(x){return x.label}).join(' / ');
    buildings.push([label, data.name, false]);
}

// Group like buildings for menu. Needs to be manual, because it's a judgement call.
var buildGroups = [
    ["Kitten Housing", ["hut", "logHouse", "mansion"]],
    ["Craft Bonuses", ["workshop", "factory"]],
    ["Production", ["field", "pasture", "mine", "lumberMill", "aqueduct", "oilWell", "quarry"]],
    ["Conversion", ["smelter", "biolab", "calciner", "reactor", "accelerator", "steamworks", "magneto"]],
    ["Science", ["library", "academy", "observatory"]],
    ["Storage", ["barn", "harbor", "warehouse"]],
    ["Culture", ["amphitheatre", "chapel", "temple"]],
    ["Other", ["tradepost", "mint", "unicornPasture", /*...*/]],
    ["Megastructures", ["ziggurat", "chronosphere", "aiCore"]],
];
// Add missing buildings to "Other"
for (var i=0; i<buildings.length; i++) {
    if (! buildGroups.map(function(x){return x[1]}).flat().includes(buildings[i][1])) {
        for (var j=0; j<buildGroups.length; j++) {
            if (buildGroups[j][0] == "Other") buildGroups[j][1].push(buildings[i][1]);
        }
    }
}

var spaceBuildings = [/*
    ["Space Elevator", "spaceElevator", false],
    ...
*/];
var spaceGroups = [/*
    ["cath", ["spaceElevator", "sattelite", "spaceStation"]],
    ...
*/];
for (var i=0; i<gamePage.space.planets.length; i++) {
    var planet = gamePage.space.planets[i];
    var inGroup = [];
    for (var j=0; j<planet.buildings.length; j++) {
        var data = planet.buildings[j];
        if (! data.stages) var label = data.label;
        else var label = data.stages.map(function(x){return x.label}).join(' / ');
        spaceBuildings.push([label, data.name, false]);
        inGroup.push(data.name);
    }
    spaceGroups.push([planet.label, inGroup]);
}

var resources = [
    [    "wood", [["catnip", 50]]],
    [    "beam", [["wood", 175]]],
    [    "slab", [["minerals", 250]]],
    [   "steel", [["iron", 100],["coal", 100]]],
    [   "plate", [["iron", 125]]],
    [   "alloy", [["titanium", 10],["steel", 75]]],
    ["kerosene", [["oil", 7500]]],
    [ "thorium", [["uranium", 250]]],
    [ "eludium", [["unobtainium", 1000],["alloy", 2500]]],
    ["scaffold", [["beam", 50]]],
    ["concrate", [["steel", 25],["slab", 2500]]], // sic concrate
    [    "gear", [["steel", 15]]],
    /* These must be last, anything after may be skipped by paperStarts..paperChoice */
    [ "parchment", [["furs",175]]],
    ["manuscript", [["parchment", 20],["culture",300]]],
    [ "compedium", [["manuscript", 50],["science",10000]]], // sic compedium
    [ "blueprint", [["compedium", 25],["science",25000]]]
];
var paperStarts = resources.findIndex(function(r){return r[0]=='parchment'});

var htmlMenuAddition = '<div id="farRightColumn" class="column">' +

'<a id="scriptOptions" onclick="selectOptions()"> | ScriptKitties </a>' +

'<div id="optionSelect" style="display:none; margin-top:-125%; margin-left:-65px; width:200px" class="dialog help">' +
'<a href="#" onclick="clearOptionHelpDiv();" style="position: absolute; top: 10px; right: 15px;">close</a>' +

'<button id="killSwitch" onclick="clearInterval(clearScript()); gamePage.msg(deadScript);">Kill Switch</button> </br>' +
'<button id="efficiencyButton" onclick="kittenEfficiency()">Check Efficiency</button></br></br>' +
autoButton('build', "Auto Build") + '</br>' +
'<button id="bldSelect" onclick="selectBuildings()">Select Building</button></br>' +

autoButton('assign', "Auto Assign") +
'<select id="autoAssignChoice" size="1" onclick="setAutoAssignValue()">' +
'<option value="woodcutter">Woodcutter</option>' +
'<option value="farmer" selected="selected">Farmer</option>' +
'<option value="scholar">Scholar</option>' +
'<option value="hunter">Hunter</option>' +
'<option value="miner">Miner</option>' +
'<option value="priest">Priest</option>' +
'<option value="geologist">Geologist</option>' +
'<option value="engineer">Engineer</option>' +
'</select></br>' +

autoButton('craft', "Auto Craft") +
'<select id="craftFur" size="1" onchange="setFurValue()">' +
'<option value="none" selected="selected">None</option>' +
'<option value="parchment">Parchment</option>' +
'<option value="manuscript">Manuscript</option>' +
'<option value="compedium">Compendium</option>' +
'<option value="blueprint">Blueprint</option>' +
'</select></br>' +
'<label id="secResLabel"> Secondary Craft % </label>' +
'<span id="secResSpan" title="Between 0 and 100"><input id="secResText" type="text" style="width:25px" onchange="secResRatio = this.value" value="' + secResRatio + '"></span></br></br>' +


autoButton('hunt', "Auto Hunt") + '</br>' +
autoButton('trade', "Auto Trade") + '</br>' +
autoButton('praise', "Auto Praise") + '</br>' +
autoButton('party', "Auto Party") + '</br>' +
'<br>' +

autoButton('embassy', "Auto Embassy") + '</br>' +
autoButton('cycle', "Auto Cycle") + '</br>' +
'<select id="cycleChoice" size="1" onchange="setCycleChoice()">';
for (var i = 0; i < game.calendar.cycles.length; i++) {
    var cycle = game.calendar.cycles[i];
    var sel = (i==cycleChoice) ? ' selected="selected"' : '';
    var label = `${cycle.glyph} ${cycle.title}`;
    htmlMenuAddition += `<option value="${i}"${sel}>${label}</option>`;
}
htmlMenuAddition += '</select></br>' +
'</br>' +

autoButton('research', 'Auto Science') + '</br>' +
autoButton('workshop', 'Auto Upgrade') + '</br>' +
autoButton('religion', 'Auto Religion') + '</br>' +
autoButton('unicorn' , 'Auto Unicorn') + '</br>' +
autoButton('energy'  , 'Energy Control') + '</br>' +
autoButton('bcoin'   , 'Auto BCoin') + '</br>' +
'</div>' +
'</div>'
$("#footerLinks").append(htmlMenuAddition);


var bldSelectAddition = '<div id="buildingSelect" style="display:none; margin-top:0px; top:50% !important; transform:translateY(-50%); width:400px; -webkit-columns: 100px 2; -webkit-column-gap: 20px; -webkit-column-rule: 4px double #DE8D47;" class="dialog help">' +
    '<a href="#" onclick="$(\'#spaceSelect\').toggle(); $(\'#buildingSelect\').hide();" style="position: absolute; top: 10px; left: 15px;">space</a>' +
    '<a href="#" onclick="$(\'#buildingSelect\').hide();" style="position: absolute; top: 10px; right: 15px;">close</a>' +
    '<br>';
bldSelectAddition += buildMenu(buildGroups, buildings, 'buildings');
bldSelectAddition += '</div>';


var spaceSelectAddition = '<div id="spaceSelect" style="display:none; margin-top:0px; top:50% !important; transform:translateY(-50%); width:200px" class="dialog help">' +
    '<a href="#" onclick="$(\'#spaceSelect\').hide(); $(\'#buildingSelect\').toggle();" style="position: absolute; top: 10px; left: 15px;">cath</a>' +
    '<a href="#" onclick="$(\'#spaceSelect\').hide();" style="position: absolute; top: 10px; right: 15px;">close</a>' +
    '	</br></br><input type="checkbox" id="programs" class="programs" onchange="programBuild = this.checked; console.log(this.checked);"><label for="programs">Programs</label></br></br>';
spaceSelectAddition += buildMenu(spaceGroups, spaceBuildings, 'spaceBuildings');
spaceSelectAddition += '</div>';

function autoButton(id, label) {
    element = 'auto' + id[0].toUpperCase() + id.slice(1);
    button = `<button id="${element}" style="color:red" onclick="autoSwitch('${id}', '${element}');"> ${label} </button>`;
    return button;
}

function buildMenu(groups, elements, elementsName) {
    var menu = '';
    for (var i = 0; i < groups.length; i++) {
        var label = groups[i][0];
        var lab = label.substring(0,3); // used for prefixes, "lab" is prefix of "label"
        menu += `	<input type="checkbox" id="${lab}Checker" onclick="selectChildren(\'${lab}Checker\',\'${lab}Check\');"><label for="${lab}Checker"><b>${label}</b></label><br>`;

        for (var j = 0; j < groups[i][1].length; j++) {
            var bld = groups[i][1][j];
            for (var k = 0; k < elements.length; k++) {
                if (bld == elements[k][1]) {
                    bldLabel = elements[k][0];
                    bldNum = k;
                    break;
                }
            }
            menu += `	<input type="checkbox" id="${bld}" class="${lab}Check" onchange="verifyElementSelected(\'${bld}\',${elementsName})"><label for="${bld}"> ${bldLabel}</label><br>`;
        }
        menu += '<br>';
    }
    return menu;
}

function selectChildren(checker, checkee) {
    $('.'+checkee).prop('checked', document.getElementById(checker).checked).change();
}

function verifyElementSelected(id, elements) {
    var isChecked = document.getElementById(id).checked;
    for (var i=0; i<elements.length; i++) {
        if (elements[i][1] == id) {
            elements[i][2] = isChecked;
            return;
        }
    }
}

$("#game").append(bldSelectAddition);
$("#game").append(spaceSelectAddition);

function clearOptionHelpDiv() {
    $("#optionSelect").hide();
}

function selectOptions() {
    $("#optionSelect").toggle();
}

function clearHelpDiv() {
    $("#buildingSelect").hide();
}

function selectBuildings() {
    $("#buildingSelect").toggle();
}

function setFurValue() {
    paperChoice = $('#craftFur').val();
}

function setAutoAssignValue() {
    autoChoice = $('#autoAssignChoice').val();
}

function setCycleChoice() {
    cycleChoice = parseInt($('#cycleChoice').val());
}

function autoSwitch(id, element) {
    auto[id] = !auto[id];
    gamePage.msg(`${element} is now  ${(auto[id] ? 'on' : 'off')}`);
    document.getElementById(element).style.color = auto[id] ? 'black' : 'red';
}

function clearScript() {
    $("#farRightColumn").remove();
    $("#buildingSelect").remove();
    $("#spaceSelect").remove();
    $("#scriptOptions").remove();
    clearInterval(runAllAutomation);
    autoBuildCheck = null;
    bldSelectAddition = null;
    spaceSelectAddition = null;
    htmlMenuAddition = null;
}

// Show current kitten efficiency in the in-game log
function kittenEfficiency() {
    var secondsPlayed = game.calendar.trueYear() * game.calendar.seasonsPerYear * game.calendar.daysPerSeason * game.calendar.ticksPerDay / game.ticksPerSecond;
    var numberKittens = gamePage.resPool.get('kittens').value;
    var curEfficiency = (numberKittens - 70) / (secondsPlayed / 3600);
    gamePage.msg("Your current efficiency is " + parseFloat(curEfficiency).toFixed(2) + " Paragon per hour.");
}


/* These are the functions which are controlled by the runAllAutomation timer */
/* These are the functions which are controlled by the runAllAutomation timer */
/* These are the functions which are controlled by the runAllAutomation timer */
/* These are the functions which are controlled by the runAllAutomation timer */
/* These are the functions which are controlled by the runAllAutomation timer */


// Auto Observe Astronomical Events
function autoObserve() {
    var checkObserveBtn = document.getElementById("observeBtn");
    if (typeof(checkObserveBtn) != 'undefined' && checkObserveBtn != null) {
        document.getElementById('observeBtn').click();
    }
}

// Auto praise the sun
function autoPraise() {
    if (auto.praise && gamePage.bld.getBuildingExt('temple').meta.val > 0) {
        gamePage.religion.praise();
    }
}

// Build buildings automatically
function autoBuild() {
    if (auto.build && gamePage.ui.activeTabId == 'Bonfire') {
        var btn = gamePage.tabs[0].buttons;

        for (var z = 0; z < buildings.length; z++) {
            if (buildings[z][2] && gamePage.bld.getBuildingExt(buildings[z][1]).meta.unlocked) {
                for (i = 2; i < gamePage.tabs[0].buttons.length; i++) {
                    if (btn[i].model.metadata.name == buildings[z][1]) {
                        try {
                            btn[i].controller.buyItem(btn[i].model, {}, function(result) {
                                if (result) {btn[i].update();}
                            });
                        } catch(err) {
                            console.log(err);
                        }
                    }
                }
            }
        }
        if (gamePage.getResourcePerTick('coal') > 0.01 && steamOn < 1) {
            gamePage.bld.getBuildingExt('steamworks').meta.on = gamePage.bld.getBuildingExt('steamworks').meta.val;
            steamOn = 1;
        }
    }
}

// Build space stuff automatically
function autoSpace() {
    if (auto.build && gamePage.tabs[6] && gamePage.tabs[6].planetPanels) {
        // Build space buildings
        outer: for (var z = 0; z < spaceBuildings.length; z++) {
            if (spaceBuildings[z][2] && gamePage.space.getBuilding(spaceBuildings[z][1]).unlocked) {

                for (i = 0; i < gamePage.tabs[6].planetPanels.length; i++) {
                    for (j = 0; j < gamePage.tabs[6].planetPanels[i].children.length; j++) {
                        var spBuild = gamePage.tabs[6].planetPanels[i].children[j];
                        if (spaceBuildings[z][1] == spBuild.id) {
                            // .enabled doesn't update automatically unless the tab is active, force it
                            if (! spBuild.model.enabled) spBuild.controller.updateEnabled(spBuild.model);
                            if (spBuild.model.enabled) {
                                spBuild.controller.buyItem(spBuild.model, {}, function(result) {
                                    if (result) {spBuild.update();}
                                });
                            }
                            continue outer;
                        }
                    }
                }
            }
        }

        // Build space programs
        if (programBuild && gamePage.tabs[6] && gamePage.tabs[6].GCPanel) {
            var spcProg = gamePage.tabs[6].GCPanel.children;
            for (var i = 0; i < spcProg.length; i++) {
                if (spcProg[i].model.metadata.unlocked && spcProg[i].model.on == 0) {
                    if (! spcProg[i].model.enabled) spcProg[i].controller.updateEnabled(spcProg[i].model);
                    if (spcProg[i].model.enabled) {
                        spcProg[i].controller.buyItem(spcProg[i].model, {}, function(result) {
                            if (result) {spcProg[i].update();}
                        });
                    }
                }
            }
        }
    }
}

// Trade automatically
function autoTrade() {
    var ticksPerCycle = 25;
    // autoTrade happens every 25 ticks
    if (auto.trade) {
        var goldResource = gamePage.resPool.get('gold');
        var goldPerCycle = gamePage.getResourcePerTick('gold') * ticksPerCycle;
        var powerResource = gamePage.resPool.get('manpower');
        var powerPerCycle = gamePage.getResourcePerTick('manpower') * ticksPerCycle;
        var powerPerCycle = Math.min(powerPerCycle, powerResource.value); // don't try to spend more than we have
        var sellCount = Math.floor(Math.min(goldPerCycle/15, powerPerCycle/50));

        if (goldResource.value > (goldResource.maxValue - goldPerCycle)) { // don't check catpower
            var titRes = gamePage.resPool.get('titanium');
            var unoRes = gamePage.resPool.get('unobtainium');

            if (unoRes.value > 5000 && gamePage.diplomacy.get('leviathans').unlocked && gamePage.diplomacy.get('leviathans').duration != 0) {
                gamePage.diplomacy.tradeAll(game.diplomacy.get("leviathans"));
            } else if (titRes.value < (titRes.maxValue * 0.9) && gamePage.diplomacy.get('zebras').unlocked) {
                // don't waste the iron, make some space for it.
                var ironRes = gamePage.resPool.get('iron');
                var sellIron = game.diplomacy.get("zebras").sells[0];
                var expectedIron = sellIron.value * sellCount *
                    (1 + (sellIron.seasons ? sellIron.seasons[game.calendar.getCurSeason().name] : 0)) *
                    (1 + game.diplomacy.getTradeRatio() + game.diplomacy.calculateTradeBonusFromPolicies('zebras', game));
                if (ironRes.value > (ironRes.maxValue - expectedIron)) {
                    gamePage.craft('plate', (ironRes.value - (ironRes.maxValue - expectedIron))/125); // 125 is iron per plate
                }

                gamePage.diplomacy.tradeMultiple(game.diplomacy.get("zebras"), sellCount);
            } else if (gamePage.diplomacy.get('dragons').unlocked) {
                gamePage.diplomacy.tradeMultiple(game.diplomacy.get("dragons"), sellCount);
            }
        }
    }
}

// Build Embassies automatically
function autoEmbassy() {
    if (auto.embassy && gamePage.diplomacyTab.racePanels && gamePage.diplomacyTab.racePanels[0]) {
        var culture = gamePage.resPool.get('culture');
        if (culture.value >= culture.maxValue * 0.99) { // can exceed due to MS usage
            var panels = gamePage.diplomacyTab.racePanels;
            var btn = panels[0].embassyButton;
            for (var z = 1; z < panels.length; z++) {
                var candidate = panels[z].embassyButton;
                if (candidate && candidate.model.prices[0].val < btn.model.prices[0].val) {
                    btn = candidate;
                }
            }
            try {
                btn.controller.buyItem(btn.model, {}, function(result) {
                    if (result) {btn.update();}
                });
            } catch(err) {
                console.log(err);
            }
        }
    }
}

// Hunt automatically
function autoHunt() {
    if (auto.hunt) {
        var catpower = gamePage.resPool.get('manpower');
        if (catpower.value > (catpower.maxValue - 1)) {
            gamePage.village.huntAll();
        }
    }
}

// Craft primary resources automatically
function autoCraft() {
    /* Note: In this function, rounding gives us grief.
     * If we have enough resource to craft 3.75 of of something, and ask for
     * that, the game rounds up to 4 and then fails because we don't have
     * enough.
     *
     * However, we mostly craft "off the top", making space for production,
     * so we'll usually have the slack. But when we don't, it effectively turns
     * off autoCraft for that resource.
     *
     * On the other hand, we don't want to always round down, or else we'll be
     * wasting resources, and in some cases *cough*eludium*cough*, we'll be
     * rounding down to zero.
     */
    var ticksPerCycle = 3; // we execute every 3 ticks

    if (auto.craft) {
        // Craft primary resources
        for (var i = 0; i < resources.length; i++) {
            var output = resources[i][0];
            var inputs = resources[i][1];
            var outRes = gamePage.resPool.get(output);
            if (output == 'parchment' && paperChoice == 'none') break; // user asked for no papers
            if (! outRes.unlocked) continue;

            var craftCount = Infinity;
            for (var j = 0; j < inputs.length; j++) {
                var inRes = gamePage.resPool.get(inputs[j][0]);
                craftCount = Math.min(craftCount, Math.floor(inRes.value / inputs[j][1])); // never try to use more than we have

                if (inRes.maxValue != 0) {
                    // primary resource
                    var resourcePerCycle = gamePage.getResourcePerTick(inputs[j][0], 0) * ticksPerCycle;
                    if (resourcePerCycle < inRes.maxValue && inRes.value < (inRes.maxValue - resourcePerCycle)) {
                        craftCount = 0;
                    } else {
                        craftCount = Math.min(craftCount, resourcePerCycle / inputs[j][1]);
                    }
                } else if (i < paperStarts) {
                    // secondary resource
                    var resMath = inRes.value / inputs[j][1];
                    if (resMath <= 1 || outRes.value > (inRes.value * (secResRatio / 100))) craftCount = 0;
                    craftCount = Math.min(craftCount, resMath * (secResRatio / 100));
                } else {
                    // secondary resource: fur, parchment, manuscript, compendium
                    craftCount = Math.min(craftCount, (inRes.value / inputs[j][1]));
                }
            }
            if (craftCount == 0 || craftCount == Infinity) {
                // nothing to do
            } else if (paperChoice == 'blueprint' && output == 'compedium' && gamePage.resPool.get('compedium').value > 25) {
                // save science for making blueprints
            } else {
                gamePage.craft(output, craftCount);
            }
            if (output == paperChoice) break; // i.e. if we're processing the user's choice, then we're done
        }
    }
}

// Auto Research
function autoResearch() {
    if (auto.research && gamePage.libraryTab.visible) {
        var buttons = gamePage.libraryTab.buttons;
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].model.metadata.unlocked && buttons[i].model.metadata.researched != true) {
                if ( ! buttons[i].model.enabled) buttons[i].update();
                if (buttons[i].model.enabled) {
                    buttons[i].controller.buyItem(buttons[i].model, {}, function(result) {
                        if (result) {buttons[i].update();}
                    });
                }
            }
        }
    }
}

// Auto Workshop upgrade, tab 3
function autoWorkshop() {
    if (auto.workshop && gamePage.workshopTab.visible) {
        var buttons = gamePage.workshopTab.buttons;
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].model.metadata.unlocked && buttons[i].model.metadata.researched != true) {
                if ( ! buttons[i].model.enabled) buttons[i].update();
                if (buttons[i].model.enabled) {
                    buttons[i].controller.buyItem(buttons[i].model, {}, function(result) {
                        if (result) {buttons[i].update();}
                    });
                }
            }
        }
    }
}

// Auto buy relgion upgrades
function autoReligion() {
    if (auto.religion && gamePage.religionTab.visible) {
        var buttons = gamePage.religionTab.rUpgradeButtons;
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].model.visible && buttons[i].model.metadata.researched != true) {
                if ( ! buttons[i].model.enabled) buttons[i].update();
                if (buttons[i].model.enabled) {
                    buttons[i].controller.buyItem(buttons[i].model, {}, function(result) {
                        if (result) {buttons[i].update();}
                    });
                }
            }
        }
    }
}

// Auto buy unicorn upgrades
function autoUnicorn() {
    if (auto.unicorn && gamePage.religionTab.visible) {
        /* About Unicorn Rifts
         * Each Tower causes a 0.05% chance for a rift per game-day
         * Each rift produces 500 Unicorns * (Unicorn Production Bonus)/10
         */
        var riftUnicorns = 500 * (1 + game.getEffect("unicornsRatioReligion") * 0.1);
        var upsprc = riftUnicorns / (100000/5); // unicorns per second per riftChance
        var ups = 5 * gamePage.getResourcePerTick('unicorns') / (1 + game.getEffect("unicornsRatioReligion"));

        // find which is the best value
        var buttons = gamePage.religionTab.zgUpgradeButtons;
        var bestButton = null;
        var bestValue = 0.0;
        for (var i = 0; i < buttons.length; i++) {
            if (buttons[i].model.metadata.unlocked) {
                var ratio = buttons[i].model.metadata.effects.unicornsRatioReligion;
                var rifts = buttons[i].model.metadata.effects.riftChance || 0;
                var tearCost = buttons[i].model.prices.find(function(element){return element.name==='tears'});
                if (tearCost == null) continue;
                var value = (ratio * ups + rifts * upsprc) / tearCost.val;
                if (value > bestValue) {
                    bestButton = buttons[i];
                    bestValue = value;
                }
            }
        }

        // can we afford it?
        if (bestButton != null) {
            var cost = bestButton.model.prices.find(function(element){return element.name==='tears'}).val;
            var unicorns = gamePage.resPool.get('unicorns').value;
            var tears = gamePage.resPool.get('tears').value;
            var zigs = game.bld.get("ziggurat").on;
            var available = tears + Math.floor(unicorns / 2500) * zigs;
            if (available > cost) {
                if (tears < cost) {
                    var sacButton = gamePage.religionTab.sacrificeBtn;
                    // XXX: I don't like calling an internal function like _transform
                    // But it's the only way to request a specific number of Unicorn sacrifices, instead of spam-clicking...
                    sacButton.controller._transform(sacButton.model, Math.ceil((cost - tears) / zigs));
                }
                if ( ! bestButton.model.enabled) bestButton.update();
                bestButton.controller.buyItem(bestButton.model, {}, function(result) {
                    if (result) {bestButton.update();}
                });
            }
        }
    }
}

// Festival automatically
function autoParty() {
    if (auto.party && gamePage.science.get("drama").researched) {
        var catpower = gamePage.resPool.get('manpower').value;
        var culture = gamePage.resPool.get('culture').value;
        var parchment = gamePage.resPool.get('parchment').value;

        if (catpower > 1500 && culture > 5000 && parchment > 2500) {
            if (gamePage.prestige.getPerk("carnivals").researched && gamePage.calendar.festivalDays < 400*10) {
                gamePage.village.holdFestival(1);
            } else if (gamePage.calendar.festivalDays == 0) {
                gamePage.village.holdFestival(1);
            }
        }
    }
}

// Auto assign new kittens to selected job
function autoAssign() {
    if (auto.assign && gamePage.village.getJob(autoChoice).unlocked) {
        gamePage.village.assignJob(gamePage.village.getJob(autoChoice), 1);
    }
}

// Try to manupulate time to force the cycle of our choosing
function autoCycle() {
    if (auto.cycle && game.calendar.cycle != cycleChoice) {
        // desired cycle: cycleChoice
        // current cycle: game.calendar.cycle
        // year in cycle: game.calendar.cycleYear
        var deltaCycle = (cycleChoice - game.calendar.cycle + game.calendar.cycles.length) % game.calendar.cycles.length;
        var deltaYears = deltaCycle*5 - game.calendar.cycleYear;
        var timeCrystals = gamePage.resPool.get('timeCrystal').value;

        // find and click the button
        if (timeCrystals != 0 && deltaYears != 0 && deltaYears <= timeCrystals) {
            for (var i = 0; i < gamePage.timeTab.children.length; i++) {
                if (gamePage.timeTab.children[i].name == "Chronoforge" && gamePage.timeTab.children[i].visible) {
                    var btn = gamePage.timeTab.children[i].children[0].children[0]; // no idea why there's two layers in the code
                    btn.controller.doShatterAmt(btn.model, deltaYears)
                }
            }
        }
    }
}

// Control Energy Consumption
function energyControl() {
    if (auto.energy) {
        proVar = gamePage.resPool.energyProd;
        conVar = gamePage.resPool.energyCons;

        if (bldAccelerator.val > bldAccelerator.on && proVar > (conVar + 3)) {
            bldAccelerator.on++;
            conVar++;
        } else if (bldCalciner.val > bldCalciner.on && proVar > (conVar + 3)) {
            bldCalciner.on++;
            conVar++;
        } else if (bldFactory.val > bldFactory.on && proVar > (conVar + 3)) {
            bldFactory.on++;
            conVar++;
        } else if (bldOilWell.val > bldOilWell.on && proVar > (conVar + 3)) {
            bldOilWell.on++;
            conVar++;
        } else if (bldBioLab.val > bldBioLab.on && proVar > (conVar + 3)) {
            bldBioLab.on++;
            conVar++;
        } else if (bldBioLab.on > 0 && proVar < conVar) {
            bldBioLab.on--;
            conVar--;
        } else if (bldOilWell.on > 0 && proVar < conVar) {
            bldOilWell.on--;
            conVar--;
        } else if (bldFactory.on > 0 && proVar < conVar) {
            bldFactory.on--;
            conVar--;
        } else if (bldCalciner.on > 0 && proVar < conVar) {
            bldCalciner.on--;
            conVar--;
        } else if (bldAccelerator.on > 0 && proVar < conVar) {
            bldAccelerator.on--;
            conVar--;
        }
    }
}

// Auto buys and sells bcoins optimally (not yet tested)
function autoBCoin() {
    if (auto.bcoin && gamePage.science.get("antimatter").researched) {
        // When the price is > 1100 it loses 20-30% of its value
        // 880+ε is the highest it could be after an implosion
        //
        // Prior was buy < 881; sell > 1099
        // However, we want to keep stuffing BC in until the last minute
        // Well, the last hour or two.
        if (gamePage.calendar.cryptoPrice < 1095) {
            gamePage.diplomacy.buyBcoin();
        } else if (gamePage.resPool.get('blackcoin').value > 0) {
            gamePage.diplomacy.sellBcoin();
        }
    }
}

function autoNip() {
    if (auto.build) {
        if (gamePage.bld.buildingsData[0].val < 20) {
            $(".btnContent:contains('Gather')").trigger("click");
        }
    }
}

// This function keeps track of the game's ticks and uses math to execute these functions at set times relative to the game.
// Offsets are staggered to spread out the load. (Not that there is much).
clearInterval(runAllAutomation);
var runAllAutomation = setInterval(function() {
    autoNip();
    autoPraise();
    autoBuild();

    ticks = gamePage.timer.ticksTotal

    // every 0.6 seconds
    switch (ticks % 3) {
        case 0: autoCraft(); break;
        case 1: autoObserve(); autoHunt(); autoAssign(); break;
        case 2: energyControl(); break;
    }

    // every 2 seconds == every game-day
    switch (ticks % 10) {
        case 1: autoSpace(); break;
        case 2: autoParty(); break;
    }

    // every 5 seconds
    switch (ticks % 25) {
        case  2: autoResearch(); break;
        case  7: autoWorkshop(); break;
        case 12: autoReligion(); break;
        case 17: autoTrade();    break;
        case 22: autoEmbassy();  break;
    }

    // every minute
    switch (ticks % 300) {
        case   1: autoCycle();   break;
        case 101: autoUnicorn(); break;
        case 203: autoBCoin();   break;
    }
}, 200);
